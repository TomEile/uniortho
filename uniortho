#!/usr/bin/env bash
# This script was generated by bashly 1.1.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
uniortho_usage() {
  if [[ -n $long_usage ]]; then
    printf "uniortho - determine unique orthogroups based on pangenome\n"
    echo

  else
    printf "uniortho - determine unique orthogroups based on pangenome\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  uniortho COMMAND\n"
  printf "  uniortho [COMMAND] --help | -h\n"
  printf "  uniortho --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   running the pipeline\n" "$(green "run") "
  printf "  %s   test the pipeline's dependencies\n" "$(green "test")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(magenta "--version, -v")"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
uniortho_run_usage() {
  if [[ -n $long_usage ]]; then
    printf "uniortho run - running the pipeline\n"
    echo

  else
    printf "uniortho run - running the pipeline\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  uniortho run SPECIES [OPTIONS]\n"
  printf "  uniortho run --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--outfolder, -o OUTFOLDER")"
    printf "    Supply your output folder, by default, it will be in ../results\n"
    printf "    Default: ./results\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--ani, -a ANI")"
    printf "    The treshold ANI to remove highly similar samples.\n"
    printf "    Default: 99.98\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--input_files, -i GENOMES_LIST")"
    printf "    Supply the file with paths to fna files that need to be included\n"
    printf "    Default: \n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--threads, -t THREADS")"
    printf "    Supply number of threads used\n"
    printf "    Default: 16\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--gtdb_version_url, -g URL")"
    printf "    to use a different version of gtdb, supply the URL here\n"
    printf "    Default: https://data.gtdb.ecogenomic.org/releases/latest/bac120_metadata.tsv.gz\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--completeness, -c COMPLETENESS")"
    printf "    Supply the minimum completeness threshold to select genomes on\n"
    printf "    Default: 95\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--contamination, -C CONTAMINATION")"
    printf "    Supply the maximum contamination threshold to select genomes on\n"
    printf "    Default: 5\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--blast, -b")"
    printf "    check the unique orthogroups by blasting them against the NCBI nt database.\n    This takes a long time to run.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "SPECIES")"
    printf "    name of the species, leading with the s__ (using gtdb taxonomy)\n"
    echo

  fi
}

# :command.usage
uniortho_test_usage() {
  if [[ -n $long_usage ]]; then
    printf "uniortho test - test the pipeline's dependencies\n"
    echo

  else
    printf "uniortho test - test the pipeline's dependencies\n"
    echo

  fi

  printf "Alias: t\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  uniortho test [OPTIONS]\n"
  printf "  uniortho test --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--blast, -b")"
    printf "    check the unique orthogroups by blasting them against the NCBI nt database\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/check_if_script_in_bin.sh
script_in_bin(){

command=$1

if [[ ! -s $HOME/.local/bin/$command ]]; then
        echo "$(red $command not found in $HOME/.local/bin.)"
        echo "$(red add the script to your path, for example with)"
        echo "$(magenta ln -s $PWD/src/lib/$command $HOME/.local/bin)"
        exit 1
fi
}

# src/lib/check_requirements.sh
check_requirement(){

    cmd=$1
    if ! command -v $cmd &> /dev/null
    then
        echo "$(magenta $cmd) could not be found. Please install $cmd and add it to your PATH"
        echo "Or if using conda, $(green activate your conda environment)"
        exit
    fi
}

check_requirements(){

    check_requirement "scarap"
    check_requirement "skani"
    check_requirement "prodigal"
    check_requirement "Rscript"
    check_requirement "blastn"

}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/download_fnas.sh
download_fnas() {
  #inspect_args
fin="$1"
dout=$2

[ -d $dout ] || mkdir -p $dout

for acc in $(cat "$fin" | cut -f 1) ; do
  if $(ls $dout | grep -q ${acc:3}); then
    echo "$(blue skipping download of ${acc:3})"
    continue
  fi

  url=ftp.ncbi.nlm.nih.gov/genomes/all/${acc:3:3}/${acc:7:3}/${acc:10:3}/${acc:13:3}/${acc:3}*/${acc:3}*_genomic.fna.gz
  echo "$(green downloading ${acc:3}...)"
     exitcode=1

     attempt=1
     while [[ $exitcode -ne 0 ]] && [[ $attempt -le 5 ]] ; do
       if [[ $attempt -ne 1 ]] ; then sleep 10 ; echo attempt $attempt ; fi
       rsync --copy-links --times --verbose \
           --exclude *_cds_from_genomic.fna.gz \
           --exclude *_rna_from_genomic.fna.gz \
           rsync://$url $dout > /dev/null 2>&1
       exitcode=$?
       attempt=$((attempt + 1))
       #echo $exitcode $attempt
       if [[ $exitcode -ne 0 ]] && [[ $attempt -eq 6 ]] ; then

         echo "$(red could not find .fna of ${acc:3}, skipping...)"
         echo $acc >> $dout/failed.txt
       fi
     done
done

}

# src/lib/fetch_genes.sh
fetch_genes(){
din=$1
filtered_pan=$2

if [[ -n $(find "$din/fetch/fastas" -type f -name "*.fasta") ]]; then
    echo "$(blue $din/fetch/fastas already exists. Skipping fetch)"
else

ls $din/ffns/* > $din/input_ffns.txt
cat $din/input_ffns.txt
scarap fetch $din/input_ffns.txt $din/pan/pangenome.tsv $din/fetch
# cleanup
rm $din/input_ffns.txt
fi
}

# src/lib/prepare_genomes.sh
prepare_genomes(){
    data_folder="$1"
    gtdb_url="$2"
    species="$3"
    completeness="$4"
    contamination="$5"
    genomes_list="$6"
    outf="$7"

    [ -d $data_folder ] || mkdir -p $data_folder

    # download GTDB bac120 metadata if needed
    bac120_file=$(basename "${gtdb_url}" .tar.gz)

    if [[ -n $(find "$data_folder" -type f -name "$bac120_file*") ]]; then
        echo "$(blue $bac120_file already exists. Skipping download)"
    else
        echo "$(green $bac120_file File doesn\'t exist, downloading...)"
        wget $gtdb_url -P $data_folder
    fi

    # check if a selection of this species is already made
    selection="$data_folder/${species}_selection.tsv"
    selection_file_name=$(basename "${selection}")

    if [[ -n $(find $data_folder -type f -name "$selection_file_name*") ]]; then
        echo "$(blue $selection_file_name already exists.)"
    else
        echo "$(green $selection_file_name File doesn\'t exist, subsetting $bac120_file...)"
        # GTDB tax is in column 17 or 20; filter there
        taxcol=`zcat $data_folder/$bac120_file | awk -v RS='\t' '/taxonomy/{print NR; exit}'`
        # also filter for contam and completeness
        {
            zless $data_folder/$bac120_file \
            | awk -F "\t" -v species="$species" \
                -v taxcol=$taxcol -v complete="$completeness" -v contam="$contamination" \
                '$taxcol ~ species &&  $3 >= complete && $4 <= contam' > "$selection"
        }
    fi

    # raise error if no genomes are found
    if [[ ! -s "$selection" ]]; then
        echo "$(red No genomes found for $species. Exiting...)"
        exit 1
    fi

    download_fnas "$selection" $outf/fnas
    #if you have non-public genomes, add your own fnas files in the correct folder before running the next steps: maybe automate
    if [[ ! -n "$genomes_list" ]]; then
        while read f; do
            if [[ ! -s "$f" ]]; then
                echo "$(cyan File $f not found. Ignoring it...)"
            else
                cp $f $outf/fnas
            fi
        done < $genomes_list
    fi

    run_prodigal $outf

}

# src/lib/run_blast_check.sh
#!/usr/bin/env bash
#requirements: blastn
run_blast_check(){
din=$1/fetch/fastas
dgenomes=$1/fnas
uqgenes=$1/uniquegenes.tsv
dout=$1/blast
threads=$2

mkdir -p $dout

echo "$(green Running blast against nt database)"
tail -n +2 $uqgenes |
cut -d ' ' -f 3 |
awk -v d="$din/" '$0='d'$0".fasta"' |
xargs cat |
blastn -query - -db nt -remote \
 -out $dout/results -outfmt 6

}

# src/lib/run_fastani.sh
#!/usr/bin/env bash
#requirements: fastANI
run_fastani(){
fin=$1
dout="../results/$(basename $fin .tsv)"
echo $dout
exit
id=$(find $dout/fnas -name "$2*")
echo $id
ls $dout/fnas/* > $dout/input_fnas.txt

[ -d "$dout/fastani" ] || mkdir -p "$dout/fastani"
fastANI -q $id --rl $dout/input_fnas.txt -o $dout/fastani/${2}_ani.txt

}

# src/lib/run_pangenome.sh
# dependency: scarap
run_pangenome() {
#input variables based on in and output
#variables change how many threads you want to use
din=$1/faas
dout=$1/pan
threads=$2
[ -d "$dout" ] || mkdir -p "$dout"
scarap pan $din $dout -t $threads -c
}

# src/lib/run_prodigal.sh
#!/usr/bin/env bash
run_prodigal() {

dout=$1
din=$dout/fnas

[ -d "$dout/faas" ] || mkdir -p "$dout/faas"
[ -d "$dout/ffns" ] || mkdir -p "$dout/ffns" #needed for extraction of the genes of interest
for F in $din/*.fna.gz;
	do N=$(basename $F .fna.gz);
    if test -s "$dout/faas/$N.faa"; then
        echo "$(blue $dout/faas/$N.faa already exists. Skipping prodigal)"
    else
        echo "$(green Running prodigal on $N.fna.gz)"
        zcat $F | prodigal -a $dout/faas/$N.faa -d $dout/ffns/$N.ffn -q >/dev/null;
    fi
done
}

# src/lib/run_skani.sh
run_skani(){
    dout=$1
    skani triangle --full-matrix $dout/fnas/* > $dout/ani
    rm skani_matrix.af
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_float.sh
validate_float() {
  [[ "$1" =~ ^[0-9]+(\.[0-9]+)?$ ]] || echo "must be a float"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# :command.command_functions
# :command.function
uniortho_run_command() {
  # src/run_command.sh
  data_folder=./data
  species=${args[species]}
  genomes_list=${args[genomes_list]}
  outf=${args[--outfolder]}
  gtdb_url=${args[--gtdb_version_url]}
  completeness=${args[--completeness]}
  contamination=${args[--contamination]}
  cpus=${args[--threads]}
  ani_threshold=${args[--ani]}
  blast_check=${args[--blast]}

  # Add s__ to species if absent
  if [[ $species != s__* ]]; then
      species="s__$species"
  fi

  # check for requirements: R, scarap and skani
  check_requirements

  if [[ ! -s "$outf/pan/pangenome.tsv" ]]; then
      prepare_genomes "$data_folder" \
      "$gtdb_url" \
      "$species" \
      "$completeness" \
      "$contamination" \
      "$genomes_list "\
      "$outf"

      run_pangenome $outf $cpus
  else
      echo "$(blue Pangenome already exists. Skipping pangenome calculation)"
  fi

  #using skani here, since its 'supposed to be better' for highly similar ANIs
  # and those are the ones we want to remove

  #run_fastani $out $species

  if [[ ! -s "$outf/ani" ]]; then
      run_skani $outf
  else
      echo "$(blue ANI matrix already exists. Skipping ANI calculation)"
  fi

  # Rscript should be added to path and called from there
  if [[ ! -s $HOME/.local/bin/uo_filter_unique_genes.R ]]; then
      echo "$(red uo_filter_unique_genes.R not found in $HOME/.local/bin.)"
      echo "$(red add the script to your path, for example with)"
      echo "$(magenta ln -s $PWD/src/lib/uo_filter_unique_genes.R $HOME/.local/bin)"
      exit 1
  fi

  script_in_bin "uo_filter_unique_genes.R"
  $HOME/.local/bin/uo_filter_unique_genes.R $outf/pan/pangenome.tsv $outf/ani $ani_threshold $outf
  fetch_genes $outf

  if [[ $blast_check == 1 ]]; then
      run_blast_check $outf $cpus
      script_in_bin "process_blast_check.py"
      $HOME/.local/bin/process_blast_check.py $outf/blast/results $outf/uniquegenes.tsv $outf
  fi

}

# :command.function
uniortho_test_command() {
  # src/test_command.sh
  blast_check=${args[--blast]}
  outf="test_out"

  if [[ $blast_check == 1 ]]; then
      script_in_bin "process_blast_check.py"
      if [[ ! -s "test_out/blast/results" ]]; then
      uniortho run "s__Sumerlaea chitinivorans" -C 10 -o $outf --blast
      else

          echo "$(blue Blast results already exist. Skipping blast)"
      fi
      python3 $HOME/.local/bin/process_blast_check.py $outf/blast/results $outf/uniquegenes.tsv $outf
  else
      uniortho run "s__Sumerlaea chitinivorans" -C 10 -o $outf
  fi

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        uniortho_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    run | r)
      action="run"
      shift
      uniortho_run_parse_requirements "$@"
      shift $#
      ;;

    test | t)
      action="test"
      shift
      uniortho_test_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      uniortho_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
uniortho_run_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        uniortho_run_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="run"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --outfolder | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--outfolder']="$2"
          shift
          shift
        else
          printf "%s\n" "--outfolder requires an argument: --outfolder, -o OUTFOLDER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ani | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_float "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--ani, -a ANI" "$(validate_float "$2")" >&2
            exit 1
          fi

          args['--ani']="$2"
          shift
          shift
        else
          printf "%s\n" "--ani requires an argument: --ani, -a ANI" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --input_files | -i)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_file_exists "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--input_files, -i GENOMES_LIST" "$(validate_file_exists "$2")" >&2
            exit 1
          fi

          args['--input_files']="$2"
          shift
          shift
        else
          printf "%s\n" "--input_files requires an argument: --input_files, -i GENOMES_LIST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --threads | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_integer "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--threads, -t THREADS" "$(validate_integer "$2")" >&2
            exit 1
          fi

          args['--threads']="$2"
          shift
          shift
        else
          printf "%s\n" "--threads requires an argument: --threads, -t THREADS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --gtdb_version_url | -g)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--gtdb_version_url']="$2"
          shift
          shift
        else
          printf "%s\n" "--gtdb_version_url requires an argument: --gtdb_version_url, -g URL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --completeness | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_float "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--completeness, -c COMPLETENESS" "$(validate_float "$2")" >&2
            exit 1
          fi

          args['--completeness']="$2"
          shift
          shift
        else
          printf "%s\n" "--completeness requires an argument: --completeness, -c COMPLETENESS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --contamination | -C)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_float "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--contamination, -C CONTAMINATION" "$(validate_float "$2")" >&2
            exit 1
          fi

          args['--contamination']="$2"
          shift
          shift
        else
          printf "%s\n" "--contamination requires an argument: --contamination, -C CONTAMINATION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --blast | -b)

        # :flag.case_no_arg
        args['--blast']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['species']+x} ]]; then

          args['species']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['species']+x} ]]; then
    printf "missing required argument: SPECIES\nusage: uniortho run SPECIES [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--outfolder']:-} ]] || args['--outfolder']="./results"
  [[ -n ${args['--ani']:-} ]] || args['--ani']="99.98"
  [[ -n ${args['--input_files']:-} ]] || args['--input_files']=""
  [[ -n ${args['--threads']:-} ]] || args['--threads']="16"
  [[ -n ${args['--gtdb_version_url']:-} ]] || args['--gtdb_version_url']="https://data.gtdb.ecogenomic.org/releases/latest/bac120_metadata.tsv.gz"
  [[ -n ${args['--completeness']:-} ]] || args['--completeness']="95"
  [[ -n ${args['--contamination']:-} ]] || args['--contamination']="5"

}

# :command.parse_requirements
uniortho_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        uniortho_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --blast | -b)

        # :flag.case_no_arg
        args['--blast']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.0.1"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "run") uniortho_run_command ;;
    "test") uniortho_test_command ;;
  esac
}

initialize
run "$@"
